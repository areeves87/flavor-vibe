<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flavor Bible - Explore Food Pairings</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <!-- D3.js v7 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Select2 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <!-- JQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <style>
        body {
            padding-top: 20px;
            padding-bottom: 20px;
            background-color: #f8f9fa;
        }
        h2 {
            color: #2c3e50;
            font-weight: 600;
        }
        #graph-container {
            width: 100%;
            height: 600px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            position: relative;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #graph {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #graph:active {
            cursor: grabbing;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
            transition: r 0.2s ease-in-out;
        }
        .node text {
            pointer-events: none;
            font-size: 11px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            fill: #2c3e50;
            text-anchor: start;
            stroke: white;
            stroke-width: 3px;
            stroke-linejoin: round;
            paint-order: stroke;
        }
        .node .label-visible {
             visibility: visible !important;
             font-weight: bold;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            transition: stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out;
        }

        /* Level-based link styling */
        .link.level-1 {
            stroke: #ccc;
            stroke-width: 1px;
            stroke-opacity: 0.4;
        }
        .link.level-2 {
            stroke: #999;
            stroke-width: 1.5px;
            stroke-opacity: 0.6;
        }
        .link.level-3 {
            stroke: #3498db;
            stroke-width: 2.5px;
            stroke-opacity: 0.8;
        }
        .link.level-4 {
            stroke: #e74c3c;
            stroke-width: 4px;
            stroke-opacity: 1;
        }

        /* Highlight Styles */
        .node.hovered circle {
            stroke: #2c3e50;
            stroke-width: 2.5px;
        }
        .node.neighbor:not(.hovered) circle {
            stroke: #666;
            stroke-width: 2px;
        }
        .link.connected-link {
            stroke-opacity: 1;
        }
        .link.connected-link.level-1 {
            stroke: #666;
            stroke-width: 1.5px;
        }
        .link.connected-link.level-2 {
            stroke: #555;
            stroke-width: 2px;
        }
        .link.connected-link.level-3 {
            stroke: #2980b9;
            stroke-width: 3px;
        }
        .link.connected-link.level-4 {
            stroke: #c0392b;
            stroke-width: 5px;
        }
        .dimmed {
             opacity: 0.15;
        }

        .card {
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend {
            margin-top: 15px;
            font-size: 14px;
        }
        .legend span.legend-item {
            margin-right: 15px;
            display: inline-block;
            margin-bottom: 5px;
        }
        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
            border: 1px solid #ccc;
            border-radius: 2px;
        }
        #loading-indicator {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #666;
        }
        .select2-container .select2-selection--multiple {
             min-height: 38px;
             border-radius: 4px;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        .zoom-controls button {
            display: block;
            width: 32px;
            height: 32px;
            margin-bottom: 4px;
            border: 1px solid #dee2e6;
            background: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
        }
        .zoom-controls button:hover {
            background: #f8f9fa;
        }
        .instructions {
            font-size: 12px;
            color: #6c757d;
            margin-top: 10px;
        }
        .filter-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        .filter-controls label {
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }
        .filter-checkbox {
            margin-bottom: 5px;
        }
        .filter-checkbox input {
            margin-right: 6px;
        }
        .filter-buttons {
            margin-top: 10px;
        }
        .filter-buttons .btn {
            margin-right: 5px;
            margin-bottom: 5px;
        }
        .level-line {
            display: inline-block;
            height: 3px;
            width: 20px;
            margin-right: 6px;
            vertical-align: middle;
        }
        .level-line.level-1 { background: #ccc; height: 1px; }
        .level-line.level-2 { background: #999; height: 2px; }
        .level-line.level-3 { background: #3498db; height: 3px; }
        .level-line.level-4 { background: #e74c3c; height: 4px; }

        /* Search highlight */
        .node.search-match circle {
            stroke: #f39c12;
            stroke-width: 3px;
        }
        .node.search-match text {
            visibility: visible !important;
            fill: #d35400;
            font-weight: bold;
        }

        /* Slider styling */
        .slider-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        .slider-container label {
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }
        .slider-value {
            font-weight: normal;
            color: #666;
        }
        #maxNodesSlider {
            width: 100%;
        }

        /* Search box */
        .search-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        .search-container label {
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }
        #nodeSearch {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        #nodeSearch:focus {
            outline: none;
            border-color: #80bdff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .search-hint {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h2 class="mb-4 text-center">Explore Food Pairings from The Flavor Bible</h2>
        <div class="row">
            <!-- Sidebar -->
            <div class="col-lg-3 col-md-4">
                <div class="card">
                    <div class="card-body">
                        <div class="form-group">
                            <label for="flavorInput"><strong>Select base flavors:</strong></label>
                            <select id="flavorInput" class="form-control" multiple="multiple" style="width: 100%;">
                                <!-- Options populated dynamically -->
                            </select>
                        </div>
                        <!-- Legend (Dynamic) -->
                        <div id="legend" class="legend">
                            <!-- Legend items generated here -->
                        </div>
                        <!-- Filter Controls -->
                        <div class="filter-controls">
                            <label>Filter by strength:</label>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="filter-level-4" checked>
                                <span class="level-line level-4"></span>Classic (highly recommended)
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="filter-level-3" checked>
                                <span class="level-line level-3"></span>Strong
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="filter-level-2" checked>
                                <span class="level-line level-2"></span>Moderate
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="filter-level-1" checked>
                                <span class="level-line level-1"></span>Basic
                            </div>
                            <div class="filter-buttons">
                                <button id="filter-best" class="btn btn-sm btn-outline-success">Best Only</button>
                                <button id="filter-all" class="btn btn-sm btn-outline-secondary">Show All</button>
                            </div>
                            <div class="filter-checkbox" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
                                <input type="checkbox" id="mutual-only">
                                <strong>Mutual Only</strong> – Show shared pairings
                            </div>
                        </div>
                        <!-- Max Nodes Slider -->
                        <div class="slider-container">
                            <label>Max pairings: <span id="maxNodesValue" class="slider-value">All</span></label>
                            <input type="range" id="maxNodesSlider" min="5" max="100" value="100" step="5">
                            <div class="filter-buttons">
                                <button id="slider-reset" class="btn btn-sm btn-outline-secondary">Show All</button>
                            </div>
                        </div>
                        <!-- Search/Highlight -->
                        <div class="search-container">
                            <label>Find in graph:</label>
                            <input type="text" id="nodeSearch" placeholder="Type to highlight...">
                            <div class="search-hint">Highlights matching nodes</div>
                        </div>
                        <hr>
                        <div class="instructions">
                            <strong>How to use:</strong>
                            <ul class="pl-3 mb-2">
                                <li>Select ingredients above to see their pairings</li>
                                <li>Hover over nodes to see connections</li>
                                <li>Click gray nodes to add them</li>
                                <li>Drag nodes to rearrange</li>
                                <li>Scroll to zoom, drag background to pan</li>
                            </ul>
                        </div>
                        <div class="mt-2">
                            <a id="googleLink" href="#" target="_blank" class="btn btn-outline-primary btn-sm btn-block">
                                Search Selected on Google
                            </a>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Main panel -->
            <div class="col-lg-9 col-md-8">
                <div id="loading-indicator">Loading flavor data...</div>
                <div id="graph-container" style="display: none;">
                    <div class="zoom-controls">
                        <button id="zoom-in" title="Zoom in">+</button>
                        <button id="zoom-out" title="Zoom out">−</button>
                        <button id="zoom-reset" title="Reset view">⟲</button>
                    </div>
                    <svg id="graph"></svg>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>

    <script>
        // --- Embedded Flavor Data ---
        const FLAVOR_DATA = {{FLAVOR_DATA}};

        // --- Configuration ---
        const CONFIG = {
            defaultFlavors: ["chicken", "lemon"],
            googleSearchBaseUrl: "https://www.google.com/search?q=recipe+",
            forceChargeStrength: -150,
            forceLinkDistance: 80,
            selectedLabelClass: "label-visible",
            otherGroupName: "other",
            otherGroupColor: "#95a5a6",
            zoomScaleExtent: [0.2, 5]
        };

        // --- Global State ---
        let rawData = [], smallerData = [], allMains = [];
        let simulation, currentNodes = [], currentLinks = [];
        let linkElements, nodeElements;
        let activeLevels = new Set([1, 2, 3, 4]);
        let maxNodes = Infinity; // Max pairing nodes to show (Infinity = all)
        let searchTerm = '';
        let mutualOnly = false;

        // --- D3 Setup ---
        const graphContainer = d3.select("#graph-container");
        const svg = d3.select("#graph");
        let width, height;
        const color = d3.scaleOrdinal(d3.schemeTableau10);

        // --- DOM Elements ---
        const loadingIndicator = d3.select("#loading-indicator");
        const selectElement = $("#flavorInput");
        const legendDiv = d3.select("#legend");
        let mainGroup, linkGroup, nodeGroup;

        // --- Zoom Setup ---
        const zoom = d3.zoom()
            .scaleExtent(CONFIG.zoomScaleExtent)
            .on("zoom", zoomed);

        function zoomed(event) {
            if (mainGroup) {
                mainGroup.attr("transform", event.transform);
            }
        }

        // --- Initialization ---
        function initialize() {
            showLoading(true);
            calculateSize();

            // Apply zoom behavior to SVG
            svg.call(zoom);

            d3.select(window).on('resize.graph', calculateSizeAndUpdate);

            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id))
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter())
                .force("collide", d3.forceCollide().radius(12))
                .on("tick", ticked);

            // Create main group for zooming
            mainGroup = svg.append("g").attr("id", "main-group");

            // Process embedded data
            processData(FLAVOR_DATA);
            setupSelect2();
            setupEventListeners();

            linkGroup = mainGroup.append("g").attr("class", "links");
            nodeGroup = mainGroup.append("g").attr("class", "nodes");

            showLoading(false);
            calculateSize();
            updateVisualization();
        }

        // --- Utility Functions ---
        function showLoading(isLoading) {
            loadingIndicator.style("display", isLoading ? "block" : "none");
            graphContainer.style("display", isLoading ? "none" : "block");
        }

        function processData(data) {
            rawData = data;
            allMains = Array.from(new Set(rawData.map(d => d.main))).sort();
            smallerData = rawData.filter(d => allMains.includes(d.pairing));
        }

        function setupSelect2() {
            allMains.forEach(flavor => {
                if (!selectElement.find(`option[value='${CSS.escape(flavor)}']`).length) {
                    selectElement.append(new Option(flavor, flavor));
                }
            });
            selectElement.val(CONFIG.defaultFlavors);
            selectElement.select2({
                placeholder: 'Type to search flavors...',
                allowClear: true,
                maximumSelectionLength: 10
            });
        }

        function setupEventListeners() {
            selectElement.on("change", () => {
                updateVisualization();
            });

            // Zoom controls
            d3.select("#zoom-in").on("click", () => {
                svg.transition().duration(300).call(zoom.scaleBy, 1.5);
            });
            d3.select("#zoom-out").on("click", () => {
                svg.transition().duration(300).call(zoom.scaleBy, 0.67);
            });
            d3.select("#zoom-reset").on("click", () => {
                svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
            });

            // Level filter checkboxes
            [1, 2, 3, 4].forEach(level => {
                d3.select(`#filter-level-${level}`).on("change", function() {
                    if (this.checked) {
                        activeLevels.add(level);
                    } else {
                        activeLevels.delete(level);
                    }
                    applyLevelFilter();
                });
            });

            // Filter buttons
            d3.select("#filter-best").on("click", () => {
                activeLevels = new Set([3, 4]);
                updateFilterCheckboxes();
                applyLevelFilter();
            });
            d3.select("#filter-all").on("click", () => {
                activeLevels = new Set([1, 2, 3, 4]);
                updateFilterCheckboxes();
                applyLevelFilter();
            });

            // Max nodes slider
            const slider = d3.select("#maxNodesSlider");
            const sliderValue = d3.select("#maxNodesValue");
            slider.on("input", function() {
                const val = +this.value;
                maxNodes = val >= 100 ? Infinity : val;
                sliderValue.text(maxNodes === Infinity ? "All" : maxNodes);
                updateVisualization();
            });
            d3.select("#slider-reset").on("click", () => {
                maxNodes = Infinity;
                slider.property("value", 100);
                sliderValue.text("All");
                updateVisualization();
            });

            // Search/highlight
            d3.select("#nodeSearch").on("input", function() {
                searchTerm = this.value.toLowerCase().trim();
                applySearchHighlight();
            });

            // Mutual Only toggle
            d3.select("#mutual-only").on("change", function() {
                mutualOnly = this.checked;
                updateVisualization();
            });
        }

        function updateFilterCheckboxes() {
            [1, 2, 3, 4].forEach(level => {
                d3.select(`#filter-level-${level}`).property("checked", activeLevels.has(level));
            });
        }

        function applyLevelFilter() {
            if (!linkElements || !nodeElements) return;

            const selectedFlavors = getSelectedFlavors().map(f => f.toLowerCase());

            // Show/hide links based on level
            linkElements.style("display", d => activeLevels.has(d.level) ? null : "none");

            // Find nodes that have at least one visible connection
            const connectedNodeIds = new Set(selectedFlavors);
            linkElements.each(function(d) {
                if (activeLevels.has(d.level)) {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    connectedNodeIds.add(sourceId);
                    connectedNodeIds.add(targetId);
                }
            });

            // Show/hide orphaned nodes (except selected nodes which should always show)
            nodeElements.style("display", d => {
                if (selectedFlavors.includes(d.id)) return null;
                return connectedNodeIds.has(d.id) ? null : "none";
            });
        }

        function applySearchHighlight() {
            if (!nodeElements) return;
            nodeElements.classed("search-match", d => {
                if (!searchTerm) return false;
                return d.id.toLowerCase().includes(searchTerm);
            });
        }

        function calculateSize() {
            const newWidth = graphContainer.node().getBoundingClientRect().width;
            const newHeight = graphContainer.node().getBoundingClientRect().height;

            if (newWidth > 0 && newHeight > 0 && (width !== newWidth || height !== newHeight)) {
                width = newWidth;
                height = newHeight;
                svg.attr("viewBox", `0 0 ${width} ${height}`);
                if (simulation) {
                    simulation.force("center", d3.forceCenter(width / 2, height / 2));
                }
            }
        }

        function calculateSizeAndUpdate() {
            const oldWidth = width;
            const oldHeight = height;
            calculateSize();
            if ((width !== oldWidth || height !== oldHeight) && currentNodes.length > 0 && simulation) {
                simulation.alphaTarget(0.1).restart();
            }
        }

        // --- Core Update Logic ---
        function getSelectedFlavors() { return selectElement.val() || []; }

        function updateVisualization() {
            const selectedFlavors = getSelectedFlavors();
            updateGraph(selectedFlavors);
            updateGoogleLink(selectedFlavors);
            updateLegend(selectedFlavors);
        }

        function updateGoogleLink(selectedFlavors) {
            const query = selectedFlavors.join(" ");
            d3.select("#googleLink")
              .attr("href", `${CONFIG.googleSearchBaseUrl}${encodeURIComponent(query)}`)
              .classed("disabled", selectedFlavors.length === 0);
        }

        function updateLegend(selectedFlavors) {
            legendDiv.selectAll(".legend-item").remove();

            if (selectedFlavors.length > 0 && legendDiv.select("p").empty()) {
                legendDiv.insert("p", ":first-child").append("strong").text("Legend:");
            } else if (selectedFlavors.length === 0) {
                legendDiv.select("p").remove();
            }

            const legendItems = legendDiv.selectAll(".legend-item.selected")
                .data(selectedFlavors, d => d);

            legendItems.exit().remove();

            const legendEnter = legendItems.enter().append("span").attr("class", "legend-item selected");
            legendEnter.append("span").attr("class", "legend-color")
                       .style("background-color", d => color(d));
            legendEnter.append("span").text(d => d);

            legendDiv.selectAll(".legend-item.other").remove();
            const hasOtherNodes = currentNodes.some(n => n.group === CONFIG.otherGroupName);
            if (hasOtherNodes) {
                const otherItem = legendDiv.append("span").attr("class", "legend-item other");
                otherItem.append("span").attr("class", "legend-color")
                         .style("background-color", CONFIG.otherGroupColor);
                otherItem.append("span").text("Common Pairing");
            }
        }

        function updateGraph(selectedFlavors) {
            const inputFlavorsLower = selectedFlavors.map(f => f.toLowerCase());

            // Track which selected flavors each pairing connects to
            const pairingConnections = new Map(); // pairing -> { levels: Map<selectedFlavor, level>, connectedTo: Set }

            inputFlavorsLower.forEach(fl => {
                smallerData.forEach(row => {
                    let pairing = null;
                    if (row.main === fl) pairing = row.pairing;
                    else if (row.pairing === fl) pairing = row.main;
                    if (pairing && !inputFlavorsLower.includes(pairing)) {
                        if (!pairingConnections.has(pairing)) {
                            pairingConnections.set(pairing, { levels: new Map(), connectedTo: new Set() });
                        }
                        const entry = pairingConnections.get(pairing);
                        entry.connectedTo.add(fl);
                        const currentLevel = entry.levels.get(fl) || 0;
                        entry.levels.set(fl, Math.max(currentLevel, row.level || 1));
                    }
                });
            });

            // Filter to mutual pairings if toggle is on, then calculate best level
            const pairingLevels = new Map();
            for (const [pairing, entry] of pairingConnections) {
                if (!mutualOnly || entry.connectedTo.size === inputFlavorsLower.length) {
                    // Best level is the max across all connections
                    const bestLevel = Math.max(...entry.levels.values());
                    pairingLevels.set(pairing, bestLevel);
                }
            }

            // Sort pairings by level (descending) and apply maxNodes limit
            let sortedPairings = [...pairingLevels.entries()]
                .sort((a, b) => b[1] - a[1])
                .map(([pairing]) => pairing);

            if (maxNodes !== Infinity) {
                sortedPairings = sortedPairings.slice(0, maxNodes);
            }

            const nodeIds = new Set([...inputFlavorsLower, ...sortedPairings]);
            const validNodeIds = [...nodeIds].filter(id => allMains.includes(id));
            const oldNodeMap = new Map(currentNodes.map(d => [d.id, {...d}]));

            currentNodes = validNodeIds.map(fl => {
                const existingNode = oldNodeMap.get(fl);
                const newNode = {
                    id: fl,
                    group: inputFlavorsLower.includes(fl) ? fl : CONFIG.otherGroupName
                };
                if (existingNode) {
                    newNode.x = existingNode.x;
                    newNode.y = existingNode.y;
                    newNode.fx = existingNode.fx;
                    newNode.fy = existingNode.fy;
                } else {
                    newNode.x = width / 2 + (Math.random() - 0.5) * width * 0.1;
                    newNode.y = height / 2 + (Math.random() - 0.5) * height * 0.1;
                }
                return newNode;
            });

            // Calculate links
            currentLinks = [];
            const addedLinks = new Set();
            smallerData.forEach(row => {
                const sourceInNodes = validNodeIds.includes(row.main);
                const targetInNodes = validNodeIds.includes(row.pairing);
                if (sourceInNodes && targetInNodes &&
                    (inputFlavorsLower.includes(row.main) || inputFlavorsLower.includes(row.pairing))) {
                    const linkId1 = `${row.main}|${row.pairing}`;
                    const linkId2 = `${row.pairing}|${row.main}`;
                    if (!addedLinks.has(linkId1) && !addedLinks.has(linkId2)) {
                        const sourceNode = currentNodes.find(n => n.id === row.main);
                        const targetNode = currentNodes.find(n => n.id === row.pairing);
                        if (sourceNode && targetNode) {
                            currentLinks.push({
                                source: sourceNode,
                                target: targetNode,
                                value: 1,
                                level: row.level || 1
                            });
                            addedLinks.add(linkId1);
                        }
                    }
                }
            });

            // D3 Data Binding - Links
            linkElements = linkGroup.selectAll("line.link")
                .data(currentLinks, d => `${d.source.id}-${d.target.id}`);

            linkElements.exit().transition().duration(300).style("opacity", 0).remove();

            linkElements = linkElements.enter().append("line")
                .attr("class", d => `link level-${d.level}`)
                .style("opacity", 0)
                .merge(linkElements);

            // Update level classes for existing links
            linkElements.attr("class", d => `link level-${d.level}`);

            linkElements.transition().duration(300).style("opacity", 1);

            // Apply current filter
            applyLevelFilter();

            // D3 Data Binding - Nodes
            nodeElements = nodeGroup.selectAll("g.node")
                .data(currentNodes, d => d.id);

            nodeElements.exit().transition().duration(300).style("opacity", 0).remove();

            const nodeEnter = nodeElements.enter().append("g")
                .attr("class", "node")
                .style("opacity", 0)
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("click", nodeClicked)
                .on("mouseover", handleMouseOver)
                .on("mouseout", handleMouseOut);

            nodeEnter.append("circle").attr("r", 8);
            nodeEnter.append("text")
                .attr("dx", 12)
                .attr("dy", ".35em")
                .text(d => d.id)
                .style("visibility", "hidden");

            nodeElements = nodeEnter.merge(nodeElements);

            // Apply styles
            nodeElements.transition().duration(300).style("opacity", 1);

            nodeElements.select("circle")
                .transition().duration(300)
                .attr("fill", d => d.group === CONFIG.otherGroupName ? CONFIG.otherGroupColor : color(d.group));

            // Calculate which nodes have strong (level 3-4) connections
            const strongConnectionNodes = new Set();
            currentLinks.forEach(link => {
                if (link.level >= 3) {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    strongConnectionNodes.add(sourceId);
                    strongConnectionNodes.add(targetId);
                }
            });

            nodeElements.select("text").each(function(d) {
                const isSelected = inputFlavorsLower.includes(d.id);
                const hasStrongConnection = strongConnectionNodes.has(d.id);
                d3.select(this)
                  .classed(CONFIG.selectedLabelClass, isSelected)
                  .style("visibility", (isSelected || hasStrongConnection) ? "visible" : "hidden");
            });

            // Re-apply search highlight after nodes update
            applySearchHighlight();

            // Update simulation
            simulation.nodes(currentNodes);
            simulation.force("link").links(currentLinks).distance(CONFIG.forceLinkDistance);
            simulation.force("charge").strength(CONFIG.forceChargeStrength);
            simulation.alpha(0.8).restart();
        }

        // --- Interaction Handlers ---
        function nodeClicked(event, d) {
            event.stopPropagation();
            if (d.group === CONFIG.otherGroupName && allMains.includes(d.id)) {
                const currentSelections = getSelectedFlavors();
                if (!currentSelections.includes(d.id)) {
                    selectElement.val([...currentSelections, d.id]).trigger("change");
                }
            }
        }

        function handleMouseOver(event, d) {
            if (event.defaultPrevented) return;

            const nodeGroupElement = d3.select(this);
            const allNodes = nodeElements;
            const allLinks = linkElements;
            const textElement = nodeGroupElement.select('text');

            nodeGroupElement.raise();
            textElement.style("visibility", "visible");

            allNodes.classed('dimmed', true);
            allLinks.classed('dimmed', true);

            const connectedLinks = allLinks.filter(l => l.source.id === d.id || l.target.id === d.id);

            const neighborNodeIds = new Set([d.id]);
            connectedLinks.each(function(l) {
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                neighborNodeIds.add(sourceId);
                neighborNodeIds.add(targetId);
            });
            const neighborNodes = allNodes.filter(n => neighborNodeIds.has(n.id));

            neighborNodes.classed('dimmed', false).classed('neighbor', true);
            nodeGroupElement.classed('dimmed', false);
            nodeGroupElement.classed('hovered', true);
            connectedLinks.classed('dimmed', false).classed('connected-link', true);
        }

        function handleMouseOut(event, d) {
            const allNodes = nodeElements;
            const allLinks = linkElements;
            const textElement = d3.select(this).select('text');

            if (!textElement.classed(CONFIG.selectedLabelClass)) {
                textElement.style("visibility", "hidden");
            }
            allNodes.classed('dimmed', false).classed('hovered', false).classed('neighbor', false);
            allLinks.classed('dimmed', false).classed('connected-link', false);
        }

        // --- Drag Handlers ---
        function dragstarted(event, d) {
            event.sourceEvent.stopPropagation();
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // Keep node fixed after drag
        }

        // --- Tick Function ---
        function ticked() {
            if (linkElements) {
                linkElements
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
            }
            if (nodeElements) {
                nodeElements.attr("transform", d => `translate(${d.x},${d.y})`);
            }
        }

        // --- Start ---
        initialize();
    </script>
</body>
</html>
