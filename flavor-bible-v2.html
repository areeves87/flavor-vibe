<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network of Flavor Pairings</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- Select2 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <!-- JQuery (ensure it's loaded before Bootstrap JS and Select2 JS) -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <style>
        body { padding-top: 20px; padding-bottom: 20px; }
        #graph-container {
            width: 100%;
            height: 600px;
            border: 1px solid #ccc;
            position: relative;
        }
        #graph {
            display: block;
            width: 100%;
            height: 100%;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
            transition: r 0.2s ease-in-out;
        }
        /* --- Updated Node Text Style --- */
        .node text {
            pointer-events: none;
            font-size: 11px; /* Slightly larger */
            font-family: sans-serif; /* Explicit font */
            fill: #111;     /* Darker text color */
            text-anchor: start;
            /* Halo effect for readability */
            stroke: white;          /* Color of the halo (contrast with background) */
            stroke-width: 3px;      /* Thickness of the halo */
            stroke-linejoin: round; /* Smoother corners for the halo */
            paint-order: stroke;    /* Draw stroke behind the fill */
        }
        .node .label-visible {
             visibility: visible !important;
             font-weight: bold;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            transition: stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out;
        }

        /* --- Highlight Styles --- */
        .node.hovered circle {
            stroke: #333;
            stroke-width: 2.5px; /* Slightly thicker highlight */
        }
        /* Make neighbor highlight less prominent than direct hover */
        .node.neighbor:not(.hovered) circle {
            stroke: #666;
            stroke-width: 2px;
        }
        .link.connected-link {
            stroke: dodgerblue;
            stroke-opacity: 1;
            stroke-width: 2.5px;
        }
        .dimmed {
             opacity: 0.15; /* Make non-highlighted more dimmed */
        }
        /* --- End Highlight Styles --- */

        .legend {
            margin-top: 15px;
            font-size: 14px;
        }
        .legend span.legend-item {
            margin-right: 15px;
            display: inline-block;
            margin-bottom: 5px;
        }
        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
            border: 1px solid #ccc;
        }
        #loading-indicator {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #666;
        }
        .select2-container .select2-selection--multiple {
             min-height: 38px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h2 class="mb-4 text-center">Explore Food Pairings Recommended by Top Chefs!</h2>
        <div class="row">
            <!-- Sidebar -->
            <div class="col-lg-4 col-md-5">
                <div class="card">
                    <div class="card-body">
                        <div class="form-group">
                            <label for="flavorInput">Select up to 600 base flavors:</label>
                            <select id="flavorInput" class="form-control" multiple="multiple" style="width: 100%;">
                                <!-- Options populated dynamically -->
                            </select>
                        </div>
                        <!-- Legend (Dynamic) -->
                        <div id="legend" class="legend">
                            <!-- Legend items generated here -->
                        </div>
                        <hr>
                        <button id="showModalBtn" class="btn btn-info btn-sm mb-2">What is this graph?</button>
                        <button id="blogBtn" class="btn btn-secondary btn-sm mb-2">How was this made?</button>
                        <div class="mt-2">
                            <a id="googleLink" href="#" target="_blank" class="btn btn-outline-primary btn-sm">Google Selected Flavors</a>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Main panel -->
            <div class="col-lg-8 col-md-7">
                <div id="loading-indicator">Loading flavor data...</div>
                <div id="graph-container">
                    <svg id="graph"></svg>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Dialog -->
    <div class="modal fade" id="infoModal" tabindex="-1" aria-labelledby="infoModalLabel" aria-hidden="true">
        <!-- Modal content remains the same -->
         <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="infoModalLabel">A Network of Flavor Pairs</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">Ã—</span>
                    </button>
                </div>
                <div class="modal-body">
                     <p>This interactive network visualizes food flavor pairings recommended by the book <em>The Flavor Bible</em>.</p>
                    <ul>
                        <li><strong>Dots (Nodes):</strong> Represent individual ingredients/flavors. Colors correspond to the selected base flavors in the sidebar legend. Gray dots are common pairings.</li>
                        <li><strong>Lines (Links):</strong> Indicate a recommended pairing between two flavors based on the selected base flavors.</li>
                        <li><strong>Interaction:</strong>
                            <ul>
                                <li>Hover over a node to see its name and highlight its direct connections.</li>
                                <li>Click a gray node to add it to the selection in the sidebar.</li>
                                <li>Drag nodes to rearrange the layout.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Use the sidebar to select different base flavors and explore their common pairings!</p>
                    <img src="https://via.placeholder.com/700x350?text=Example+Graph+Screenshot" alt="Example Network Snapshot" class="img-fluid mt-3">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-dismiss="modal">Got it!</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>

    <script>
        // --- Configuration ---
        const CONFIG = {
            csvUrl: "flavor_bible_full.csv",
            defaultFlavors: ["chicken", "tomatoes"],
            blogUrl: "http://rpubs.com/areeves87/389547",
            googleSearchBaseUrl: "http://google.com/search?q=",
            forceChargeStrength: -150,
            forceLinkDistance: 80,
            selectedLabelClass: "label-visible",
            otherGroupName: "other",
            otherGroupColor: "#cccccc"
        };

        // --- Global State ---
        let rawData = [], smallerData = [], allMains = [];
        let simulation, currentNodes = [], currentLinks = [];
        let linkElements, nodeElements;

        // --- D3 Setup ---
        const graphContainer = d3.select("#graph-container");
        const svg = d3.select("#graph");
        let width, height;
        const color = d3.scaleOrdinal(d3.schemeCategory10); // Define color scale once

        // --- DOM Elements ---
        const loadingIndicator = d3.select("#loading-indicator");
        const selectElement = $("#flavorInput");
        const legendDiv = d3.select("#legend");
        let linkGroup, nodeGroup;

        // --- Initialization ---
        function initialize() {
            showLoading(true);
            calculateSize();
            d3.select(window).on('resize.graph', calculateSizeAndUpdate);

            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id))
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter())
                .force("collide", d3.forceCollide().radius(12))
                .on("tick", ticked);

            d3.csv(CONFIG.csvUrl).then(data => {
                processData(data);
                setupSelect2();
                setupEventListeners();
                linkGroup = svg.append("g").attr("class", "links");
                nodeGroup = svg.append("g").attr("class", "nodes");
                showLoading(false);
                calculateSize();
                updateVisualization();
            }).catch(error => {
                console.error("Error loading or processing CSV data:", error);
                loadingIndicator.text("Error loading data. Please try refreshing.");
                showLoading(false);
            });
        }

        // --- Utility Functions ---
        function showLoading(isLoading) {
             loadingIndicator.style("display", isLoading ? "block" : "none");
             graphContainer.style("display", isLoading ? "none" : "block");
        }

        function processData(data) {
            rawData = data.map(d => ({ main: d.main.toLowerCase(), pairing: d.pairing.toLowerCase() }));
            allMains = Array.from(new Set(rawData.map(d => d.main))).sort();
            smallerData = rawData.filter(d => allMains.includes(d.pairing));
        }

        function setupSelect2() {
            allMains.forEach(flavor => {
                if (!selectElement.find(`option[value='${flavor}']`).length) {
                    selectElement.append(new Option(flavor, flavor));
                }
            });
            selectElement.val(CONFIG.defaultFlavors);
            selectElement.select2({ placeholder: 'Select base flavors', allowClear: true });
        }

        function setupEventListeners() {
            selectElement.on("change", updateVisualization);
            d3.select("#showModalBtn").on("click", () => $('#infoModal').modal('show'));
            d3.select("#blogBtn").on("click", () => window.open(CONFIG.blogUrl, "_blank"));
        }

        function calculateSize() {
            const newWidth = graphContainer.node().getBoundingClientRect().width;
            const newHeight = graphContainer.node().getBoundingClientRect().height;
            if (newWidth > 0 && newHeight > 0 && (width !== newWidth || height !== newHeight)) {
                width = newWidth; height = newHeight;
                svg.attr("viewBox", `0 0 ${width} ${height}`);
                if (simulation) simulation.force("center", d3.forceCenter(width / 2, height / 2));
            }
        }

        function calculateSizeAndUpdate() {
            const oldWidth = width; const oldHeight = height;
            calculateSize();
            if ((width !== oldWidth || height !== oldHeight) && currentNodes.length > 0 && simulation) {
                 simulation.alphaTarget(0.3).restart();
            }
        }

        // --- Core Update Logic ---
        function getSelectedFlavors() { return selectElement.val() || []; }

        function updateVisualization() {
            const selectedFlavors = getSelectedFlavors();
            calculateSize();
            updateGraph(selectedFlavors);
            updateGoogleLink(selectedFlavors);
            updateLegend(selectedFlavors);
        }

        function updateGoogleLink(selectedFlavors) {
            const query = selectedFlavors.join("+");
            d3.select("#googleLink")
              .attr("href", `${CONFIG.googleSearchBaseUrl}${encodeURIComponent(query)}`)
              .classed("disabled", selectedFlavors.length === 0);
        }

        function updateLegend(selectedFlavors) {
            legendDiv.selectAll(".legend-item").remove();
            if (legendDiv.select("p").empty() && selectedFlavors.length > 0) {
                 legendDiv.insert("p", ":first-child").append("strong").text("Legend:");
            }
            const legendItems = legendDiv.selectAll(".legend-item.selected")
                .data(selectedFlavors).enter().append("span").attr("class", "legend-item selected");
            legendItems.append("span").attr("class", "legend-color").style("background-color", d => color(d));
            legendItems.append("span").text(d => d);
            const hasOtherNodes = currentNodes.some(n => n.group === CONFIG.otherGroupName);
            if (hasOtherNodes) {
                const otherItem = legendDiv.append("span").attr("class", "legend-item other");
                 otherItem.append("span").attr("class", "legend-color").style("background-color", CONFIG.otherGroupColor);
                 otherItem.append("span").text("Common Pairing");
            }
        }

        function updateGraph(selectedFlavors) {
            const inputFlavorsLower = selectedFlavors.map(f => f.toLowerCase());
            // Node/Link Calculations (remain the same)
            const relatedPairings = new Set();
            inputFlavorsLower.forEach(fl => {
                smallerData.forEach(row => {
                    if (row.main === fl) relatedPairings.add(row.pairing);
                    if (row.pairing === fl) relatedPairings.add(row.main);
                });
            });
            const nodeIds = new Set([...inputFlavorsLower, ...relatedPairings]);
            const validNodeIds = [...nodeIds].filter(id => allMains.includes(id));
            const oldNodeMap = new Map(currentNodes.map(d => [d.id, d]));
            currentNodes = validNodeIds.map(fl => { /* ... node object creation ... */
                const existingNode = oldNodeMap.get(fl);
                return { id: fl, group: inputFlavorsLower.includes(fl) ? fl : CONFIG.otherGroupName, x: existingNode?.x ?? width / 2 + (Math.random() - 0.5) * 5, y: existingNode?.y ?? height / 2 + (Math.random() - 0.5) * 5, fx: existingNode?.fx, fy: existingNode?.fy };
             });
            currentLinks = []; const addedLinks = new Set();
            smallerData.forEach(row => { /* ... link object creation ... */
                const sourceInNodes = validNodeIds.includes(row.main); const targetInNodes = validNodeIds.includes(row.pairing);
                if (sourceInNodes && targetInNodes && (inputFlavorsLower.includes(row.main) || inputFlavorsLower.includes(row.pairing))) {
                    const linkId1 = `${row.main}|${row.pairing}`; const linkId2 = `${row.pairing}|${row.main}`;
                    if (!addedLinks.has(linkId1) && !addedLinks.has(linkId2)) { currentLinks.push({ source: row.main, target: row.pairing, value: 1 }); addedLinks.add(linkId1); }
                }
            });

            // D3 Data Binding (remain the same)
            linkElements = linkGroup.selectAll("line.link").data(currentLinks, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
            linkElements.exit().remove();
            linkElements = linkElements.enter().append("line").attr("class", "link").merge(linkElements);

            nodeElements = nodeGroup.selectAll("g.node").data(currentNodes, d => d.id);
            nodeElements.exit().remove();
            const nodeEnter = nodeElements.enter().append("g").attr("class", "node").style("opacity", 0)
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended))
                .on("click", nodeClicked).on("mouseover", handleMouseOver).on("mouseout", handleMouseOut);
            nodeEnter.append("circle").attr("r", 8);
            nodeEnter.append("text").attr("dx", 12).attr("dy", ".35em").text(d => d.id).style("visibility", "hidden");
            nodeElements = nodeEnter.merge(nodeElements);

            // Apply styles (color logic remains the same)
            nodeElements.transition().duration(300).style("opacity", 1);
            nodeElements.select("circle").transition().duration(300)
                .attr("fill", d => d.group === CONFIG.otherGroupName ? CONFIG.otherGroupColor : color(d.group));
            nodeElements.select("text").each(function(d) {
                const isSelected = inputFlavorsLower.includes(d.id);
                d3.select(this).classed(CONFIG.selectedLabelClass, isSelected).style("visibility", isSelected ? "visible" : "hidden");
            });

            // Simulation Update (remains the same)
            simulation.nodes(currentNodes);
            simulation.force("link").links(currentLinks).distance(CONFIG.forceLinkDistance);
            simulation.force("center").x(width / 2).y(height / 2);
            simulation.force("charge").strength(CONFIG.forceChargeStrength);
            simulation.alpha(1).restart();
        }

        // --- Interaction Handlers ---
        function nodeClicked(d) {
            if (d.group === CONFIG.otherGroupName && allMains.includes(d.id)) {
                const currentSelections = getSelectedFlavors();
                if (!currentSelections.includes(d.id)) {
                    selectElement.val([...currentSelections, d.id]).trigger("change");
                }
            }
            d3.event.stopPropagation();
        }

        // *** UPDATED handleMouseOver ***
        function handleMouseOver(d) {
            const nodeGroupElement = d3.select(this); // The <g class="node"> element
            const allNodes = nodeElements;
            const allLinks = linkElements;
            const textElement = nodeGroupElement.select('text');

            // Bring the hovered node group to the front
            nodeGroupElement.raise();

            // Make text visible
            textElement.style("visibility", "visible");

            // Dim others and highlight connections
            allNodes.classed('dimmed', true);
            allLinks.classed('dimmed', true);

            const connectedLinks = allLinks.filter(l => l.source.id === d.id || l.target.id === d.id);
            const neighborNodeIds = new Set([d.id]); // Include self
            connectedLinks.each(l => {
                neighborNodeIds.add(l.source.id);
                neighborNodeIds.add(l.target.id);
            });
            const neighborNodes = allNodes.filter(n => neighborNodeIds.has(n.id));

            // Apply highlighting classes (remove dimming from relevant elements)
            neighborNodes.classed('dimmed', false).classed('neighbor', true);
            nodeGroupElement.classed('hovered', true); // Specific hover style for the node under cursor
            connectedLinks.classed('dimmed', false).classed('connected-link', true);
        }


        function handleMouseOut(d) {
             const allNodes = nodeElements;
             const allLinks = linkElements;
             const textElement = d3.select(this).select('text');
             // Hide text ONLY if it's not a persistently visible label
             if (!textElement.classed(CONFIG.selectedLabelClass)) {
                 textElement.style("visibility", "hidden");
             }
            // Remove all interaction classes
            allNodes.classed('dimmed', false).classed('hovered', false).classed('neighbor', false);
            allLinks.classed('dimmed', false).classed('connected-link', false);
        }

        // --- Drag Handlers ---
        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
        }
        function dragged(d) { d.fx = d3.event.x; d.fy = d3.event.y; }
        function dragended(d) {
           if (!d3.event.active) simulation.alphaTarget(0);
             d.fx = d.x; d.fy = d.y; // Keep fixed
        }

        // --- Tick Function ---
        function ticked() {
            if (linkElements) linkElements.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            if (nodeElements) nodeElements.attr("transform", d => `translate(${d.x},${d.y})`);
        }

        // --- Start ---
        initialize();
    </script>
</body>
</html>